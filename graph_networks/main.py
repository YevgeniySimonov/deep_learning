from cmath import pi
import numpy as np
import matplotlib.pyplot as plt
from math import atan2, sqrt, acos, degrees, atan
from scipy.spatial import cKDTree
import time

from typing import List, Tuple, Dict
from sklearn.linear_model import RANSACRegressor

def ransac_regressor(coords: List, line_orientation = 'vertical') -> Tuple:

    if len(coords) > 1:

        data = np.array(coords, dtype=np.float_)
        
        if line_orientation == 'horizontal':
            X = data[:, 0]
            y = data[:, 1]
        else:
            X = data[:, 1]
            y = data[:, 0]

        # ransac regressor
        ransac = RANSACRegressor()
        ransac.fit(X[:, np.newaxis], y)

        # inlier_mask = ransac.inlier_mask_
        # X_ransac = X[inlier_mask]
        # y_ransac = y[inlier_mask]

        # estimate slope and intercept
        X_end_points = np.array([[X.min()], [X.max()]], dtype=np.float_)
        Y_end_points = ransac.predict(X_end_points)

        slope = (Y_end_points[1] - Y_end_points[0]) / (X_end_points[1] - X_end_points[0])
        intercept = Y_end_points[0] - slope * X_end_points[0]

        slope = slope[0]
        intercept = intercept[0]

        return slope, intercept

    return None, None


def main():

    data = np.array([(1002.0, 533.0), (1109.0, 532.5), (994.25, 657.5), (1230.5, 665.0), (965.0, 616.0), (920.0, 700.5), 
            (994.0, 704.25), (1070.0, 709.0), (1148.0, 713.0), (875.5, 740.0), (924.0, 742.5), (985.0, 746.75), 
            (1055.5, 751.5), (1076.0, 752.0), (1106.0, 754.5), (1154.5, 757.5), (1215.0, 761.0), (855.5, 773.5), 
            (899.0, 775.5), (959.5, 779.0), (1030.5, 783.0), (1110.5, 787.0), (1194.0, 792.0), (1234.0, 793.5), 
            (864.5, 807.5), (943.0, 810.0), (1002.0, 812.0), (1040.5, 814.0), (1084.0, 815.5), (1125.5, 817.0), 
            (1173.5, 818.5), (1217.5, 820.5), (1289.75, 822.5), (1290.5, 855.5), (1357.5, 931.0), (896.5, 1127.5), 
            (967.0, 1127.5), (1203.5, 1127.5), (1217.5, 1290.25), (1270.5, 1296.25), (1364.5, 1306.75), (713.5, 1805.5), 
            (737.0, 916.0), (786.0, 916.5), (762.0, 949.0), (816.0, 949.0), (858.0, 949.0), (894.5, 949.0), 
            (920.0, 949.0), (950.5, 948.5), (981.0, 948.0), (999.0, 948.0), (749.5, 983.5), (821.5, 983.5), 
            (890.5, 983.5), (761.5, 1014.5), (817.0, 1015.0), (859.5, 1015.5), (896.5, 1015.5), (921.5, 1016.5), 
            (953.0, 1017.0), (982.5, 1016.5), (1001.5, 1017.5), (1357.5, 1001.4999999999999), 
            (755.5, 1048.0), (833.5, 1048.0), (909.0, 1048.0), (761.0, 1080.0), (816.5, 1081.0), (859.0, 1082.5), (896.0, 1082.0), 
            (921.5, 1083.0), (952.5, 1083.5), (982.5, 1084.0), (1001.5, 1084.0), (1359.5, 1075.5), (749.0, 1116.0), (823.0, 1116.5), 
            (761.5, 1151.0), (817.0, 1151.0), (860.0, 1151.0), (896.5, 1151.0), (922.0, 1151.0), (953.0, 1151.5), (984.0, 1152.0), 
            (1002.0, 1152.0), (1361.0, 1149.0), (1389.0, 1149.0), (755.5, 1183.0), (847.5, 1183.0), (895.5, 1213.5), (923.0, 1213.5), 
            (753.0, 1247.5), (858.5, 1247.0), (759.5, 1283.0), (816.0, 1283.0), (859.0, 1283.0), (895.5, 1282.0), (921.5, 1282.0), 
            (952.5, 1282.0), (983.5, 1282.0), (1002.0, 1282.0), (1364.5, 1274.5), (709.5, 1318.0), (774.5, 1318.0), (866.0, 1317.0), 
            (940.0, 1315.5), (1008.0, 1315.0), (1077.5, 1314.5), (729.0, 1356.0), (797.5, 1355.0), (891.0, 1353.0), (971.5, 1352.0), 
            (1040.0, 1351.0), (1090.0, 1350.0), (1364.5, 1348.0), (774.5, 1388.5), (867.5, 1388.5), (923.0, 1388.5), (998.0, 1388.5), 
            (1078.5, 1388.5), (1364.5, 1383.0), (712.0, 1423.5), (761.5, 1423.5), (836.5, 1423.5), (911.0, 1423.5), (1010.5, 1423.5), 
            (1110.0, 1423.5), (1178.5, 1423.5), (750.0, 1460.0), (806.0, 1460.0), (866.5, 1460.0), (924.0, 1460.0), (974.0, 1460.0), 
            (998.5, 1460.0), (1054.5, 1460.0), (1142.5, 1460.0), (1327.75, 1423.5), (1365.5, 1455.0), (713.0, 1494.5), (750.5, 1494.5), 
            (806.0, 1494.5), (867.0, 1494.5), (935.0, 1494.5), (1011.5, 1494.5), (1060.5, 1494.5), (1123.5, 1494.5), (1205.0, 1494.5), 
            (1365.5, 1491.0), (771.5, 1532.0), (858.0, 1532.0), (975.0, 1532.0), (1086.5, 1532.0), (1155.0, 1532.0), (1365.5, 1526.5), 
            (732.0, 1566.0), (782.0, 1566.0), (857.0, 1566.0), (967.0, 1566.0), (1068.5, 1566.0), (1366.0, 1562.0), (757.0, 1600.0), 
            (833.0, 1600.0), (907.5, 1600.0), (962.0, 1600.0), (1019.0, 1600.0), (1099.5, 1600.0), (1168.5, 1600.0), (1368.5, 1596.5), 
            (744.5, 1636.5), (814.0, 1636.5), (882.5, 1636.5), (1369.5, 1631.5), (714.0, 1671.0), (789.0, 1671.0), (895.0, 1671.0), 
            (983.0, 1671.0), (1039.5, 1671.0), (1097.0, 1671.0), (1159.5, 1671.0), (1370.0, 1666.0), (750.5, 1707.0), (857.0, 1706.0), 
            (957.5, 1705.5), (1000.5, 1705.0), (1013.0, 1705.0), (1025.5, 1705.0), (1369.5, 1700.5), (738.0, 1741.5), (819.5, 1741.5), 
            (900.5, 1741.0), (938.5, 1740.5), (951.5, 1740.5), (1070.0, 1740.0), (1370.5, 1736.0), (764.5, 1776.0), (852.5, 1776.0), 
            (921.0, 1776.0), (952.5, 1776.0), (984.0, 1776.0), (1046.5, 1776.0), (754.0, 1812.0), (821.0, 1812.0), (896.5, 1812.5), 
            (1372.0, 1807.0), (744.0, 1847.0), (815.0, 1847.0), (896.5, 1847.0), (972.0, 1847.0), (1045.5, 1847.0), (1116.5, 1847.0), 
            (1374.0, 1842.5), (714.5, 1883.0), (727.5, 1883.0), (771.0, 1883.0), (840.5, 1883.0), (903.0, 1883.0), (979.0, 1883.0), 
            (1047.5, 1883.0), (1373.5, 1877.0), (714.5, 1917.0), (727.5, 1917.0), (758.5, 1917.0), (822.0, 1917.0), (878.5, 1917.0), 
            (935.5, 1917.0), (1004.0, 1917.0), (1074.5, 1917.0), (1375.5, 1913.5), (745.0, 1953.0), (815.0, 1953.0), (915.0, 1952.5), 
            (1016.0, 1952.0), (1376.0, 1949.0), (764.5, 1991.0), (882.5, 1990.0), (985.0, 1989.5), (1054.5, 1989.0), (1378.0, 1985.5), 
            (751.5, 2025.0), (853.0, 2025.0), (929.0, 2025.0), (992.0, 2024.5), (1080.5, 2024.0), (1163.0, 2024.0), (1378.5, 2022.0), 
            (714.5, 2061.0), (727.5, 2061.0), (772.0, 2061.0), (854.5, 2061.0), (930.5, 2061.0), (994.0, 2061.0), (1044.5, 2061.0), 
            (1379.5, 2058.0), (744.5, 2096.0), (823.0, 2096.0), (892.0, 2096.0), (981.5, 2096.0), (1076.0, 2096.0), (1153.5, 2096.0), 
            (1379.0, 2093.5), (810.0, 2132.0), (886.0, 2132.0), (975.0, 2132.0), (1019.5, 2132.0), (1045.5, 2132.0), (1103.0, 2132.0), 
            (842.5, 2169.0), (867.5, 2169.0), (919.0, 2169.0), (950.5, 2169.0), (1051.5, 2167.5), (1382.5, 2165.0), (800.0, 2207.0), 
            (854.5, 2206.0), (923.5, 2204.5), (981.5, 2204.5), (1040.0, 2203.5), (1382.0, 2201.5), (847.5, 2244.0), (918.0, 2242.5), 
            (982.0, 2241.0), (1057.0, 2240.0), (1384.5, 2237.0), (820.5, 2280.5), (887.5, 2279.0), (950.5, 2278.0), (1001.5, 2277.0), 
            (1066.5, 2276.0), (1385.0, 2274.5), (713.0, 2317.5), (765.0, 2317.5), (865.5, 2316.5), (950.0, 2315.5), (1021.0, 2314.5), 
            (1102.0, 2314.0), (1174.0, 2313.5), (1386.0, 2310.5), (713.5, 2353.0), (752.0, 2353.0), (823.0, 2353.0), (893.5, 2352.0), 
            (964.0, 2352.0), (1008.5, 2351.0), (1071.0, 2351.0), (1157.5, 2350.5), (1388.0, 2348.0), (713.5, 2388.5), (726.5, 2388.5),
            (771.5, 2388.5), (861.5, 2388.0), (939.0, 2387.5), (1007.5, 2387.5), (1074.0, 2387.0), (1125.5, 2386.5), (1184.0, 2386.5),
            (1391.0, 2383.0), (712.5, 2426.0), (725.5, 2426.0), (757.5, 2425.5), (810.5, 2425.0), (880.25, 2424.0), (971.0, 2422.5), 
            (1036.0, 2421.5), (1093.75, 2421.0), (1394.5, 2417.0), (712.0, 2464.0), (725.0, 2464.0), (770.0, 2463.0), (855.0, 2462.0),
            (950.0, 2460.5), (1036.5, 2458.5), (1096.5, 2458.0), (1397.0, 2451.0), (711.0, 2498.5), (724.0, 2498.5), (770.5, 2497.5),
            (861.5, 2496.5), (946.5, 2494.5), (1011.5, 2493.0), (1064.5, 2492.0), (1400.0, 2484.0), (710.0, 2534.0), (723.5, 2534.0),
            (775.5, 2532.5), (855.0, 2531.0), (907.5, 2530.0), (972.5, 2529.0), (1046.0, 2527.0), (1404.0, 2518.0), (709.0, 2571.0), 
            (722.0, 2571.0), (774.5, 2569.5), (854.5, 2567.0), (907.5, 2566.0), (973.0, 2564.0), (1063.5, 2562.0), (1153.0, 2560.0),
            (1408.0, 2552.5), (710.0, 2608.0), (736.0, 2608.0), (768.5, 2606.0), (827.5, 2604.5), (900.5, 2603.0), (986.5, 2600.5), 
            (1079.5, 2597.5), (1159.0, 2595.5), (1234.0, 2594.0), (1410.5, 2588.5), (712.5, 2645.5), (725.5, 2645.5), (758.0, 2644.5),
            (821.5, 2642.5), (921.5, 2639.5), (1045.5, 2636.0), (1142.5, 2633.5), (1209.0, 2631.5), (1412.0, 2626.0), (716.0, 2685.0),
            (728.0, 2685.0), (787.0, 2682.0), (891.0, 2678.5), (963.5, 2676.0), (1024.5, 2673.5), (1414.5, 2662.5), (763.5, 2720.5), 
            (867.0, 2716.5), (970.0, 2713.0), (1065.0, 2709.5), (1414.0, 2696.5), (721.0, 2761.25), (809.0, 2757.0), (922.0, 2751.75),
            (956.0, 2750.5), (987.0, 2749.0), (1024.0, 2747.5), (1062.0, 2745.5), (1160.0, 2740.5), (1246.5, 2736.5), (1415.5, 2731.5),
            (749.0, 2799.0), (806.5, 2796.25), (883.5, 2792.0), (970.5, 2787.5), (1415.5, 2768.0), (1416.0, 2804.0), (775.0, 2837.0), 
            (884.5, 2831.0), (957.5, 2827.0), (1010.5, 2824.0), (1071.0, 2820.5), (1417.5, 2841.0), (769.75, 2879.0), (866.75, 2873.0),
            (946.25, 2868.0), (1006.25, 2864.0), (1065.25, 2860.0), (1093.0, 2857.5), (1125.25, 2856.0), (1191.75, 2851.5), (1418.5, 2877.5),
            (725.0, 2918.75), (777.0, 2915.5), (856.0, 2910.5), (948.0, 2904.5), (1055.0, 2898.0), (1160.0, 2891.75), (1240.0, 2887.0), 
            (1420.5, 2915.0), (750.0, 2957.5), (794.5, 2954.0), (849.5, 2951.0), (930.75, 2945.5), (1003.5, 2940.25), (1083.25, 2935.0), 
            (1162.5, 2930.25), (1421.5, 2951.0)], dtype=np.float_)


    # data = data[0:200]

    beta1 = 1.1
    beta2 = 0.9
    theta1 = np.arcsin(1.0 / beta1)
    theta2 = np.pi - np.arcsin(beta2)

    beta = 1.0
    theta_beta = np.arcsin(1.0 / beta)

    # neigh_idxs = []
    # for i, p in enumerate(data):
    #     for j, q in enumerate(data):
    #         if i != j:
    #             if p[0] < q[0]:
    #                 # calculate theta
    #                 theta = None
    #                 for k, r in enumerate(data):
    #                     if (k != i) and (k != j):
    #                         s123 = (p - r).dot(q - r)
    #                         s113 = (p - r).dot(p - r)
    #                         s223 = (q - r).dot(q - r)
    #                         theta123 = acos(s123 / sqrt(s113 * s223))
    #                         if theta:
    #                             theta = max(theta, theta123)
    #                         else:
    #                             theta = theta123
    #                         # print(theta)
    #                 if theta:
    #                     if theta <= theta_beta:
    #                         neigh_idxs.append((i, j))



    # arrange data in ascending y-order
    idx_sorted = np.lexsort((data[:, 0], data[:, 1])) #np.argsort(data[:, 1])
    data = np.ascontiguousarray(data[idx_sorted])
    print(data)

    # tree = cKDTree(data)
    # neigh_idxs = []
    # for i, p in enumerate(data):
    #     dists, idxs = tree.query(p, k = 30)
    #     for j in idxs[1:]:
    #         q = data[j]
    #         if abs(p[0] - q[0]) < 1e-4:
    #             continue
    #         if p[0] < q[0]:
    #             theta_deg = degrees( atan( abs( (q[1]-p[1]) / (q[0]-p[0]) ) ) )
    #         else:
    #             theta_deg = degrees( atan( abs( (p[1]-q[1]) / (p[0]-q[0]) ) ) )
    #         if -7 < theta_deg < 7:
    #             neigh_idxs.append((i, j))
    


    # assuming each row has no more than 15 bounding boxes
    start = time.perf_counter()

    Kelem_search = 25

    idx_count = 0
    neigh_idxs = []
    tree = cKDTree(data[0:Kelem_search])
    last_idx = len(data)
    idx_array = np.arange(Kelem_search)
    K = len(idx_array)
    idx_set = set()
    for i, p in enumerate(data):
        if idx_count > 15:
            i1, i2 = max(i - 30, 0), min(i + 30, last_idx)
            tree = None
            tree = cKDTree(data[i1 : i2])
            idx_array = np.arange(i1, i2)
            idx_count = 0
            K = len(idx_array)
        idx_count += 1
        dists, idxs = tree.query(p, k = Kelem_search)
        for j in idxs[1:]:
            # print(idx_array)
            # print(j)
            idx = idx_array[j]
            q = data[idx]
            # calculate angle between two points
            if abs(p[0] - q[0]) < 1e-4:
                continue
            if p[0] < q[0]:
                theta_deg = degrees( atan( ( q[1] - p[1] ) / ( q[0] - p[0] ) ) )
            else:
                theta_deg = degrees( atan( ( p[1] - q[1] ) / ( p[0] - q[0] ) ) )
            # print(theta_deg)
            if -8 < theta_deg < 8:
                neigh_idxs.append((i, idx))     

    stop = time.perf_counter()
    print('Elapsed time: ', stop - start)



    # print(neigh_idxs)

    line_segments = []
    for (i, j) in neigh_idxs:
        x_values = [data[i][0], data[j][0]]
        y_values = [data[i][1], data[j][1]]
        line_segments.append([x_values, y_values])

    plt.plot(data[:, 0], data[:, 1], '.')

    # annotate points
    for i, pt in enumerate(data):
        plt.annotate(str(i), (pt[0], pt[1]))

    for line_segment in line_segments:
        x_values = line_segment[0]
        y_values = line_segment[1]
        plt.plot(x_values, y_values, 'bo', linestyle='--')
    plt.show()
    


if __name__ == '__main__':
    main()


# from pyx import canvas,path,color
# from math import *
# from random import seed,random
# seed(12345)

# npoints = 100
# radius = 0.05
# scale = 5
# beta1 = 1.1
# beta2 = 0.9
# theta1 = asin(1/beta1)
# theta2 = pi - asin(beta2)

# points = [(random()*scale,random()*scale) for i in range(npoints)]
# # print('points: ', points)

# def dot(p,q,r):
#     return sum((p[i]-r[i])*(q[i]-r[i]) for i in [0,1])

# def sharp(p,q):
#     theta = None
#     for r in points:
#         if r not in [p,q]:
#             prq = acos(dot(p,q,r) / (dot(p,p,r)*dot(q,q,r))**0.5)
#             if theta:
#                 theta = max(theta,prq)
#             else:
#                 theta = prq
#     return theta

# c = canvas.canvas()
 
# def edge1(p,q):
#     c.stroke(path.line(p[0],p[1],q[0],q[1]),
#              [color.rgb.black])

# def edge2(p,q):
#     c.stroke(path.line(p[0],p[1],q[0],q[1]),
#              [color.rgb.blue])

# def point(p):
#     c.fill(path.circle(p[0],p[1],radius),[color.rgb.red])

# for p in points:
#     for q in points:
#         print(p, q)
#         if p < q:
#             theta = sharp(p,q)
#             if theta < theta1:
#                 edge1(p,q)
#             elif theta < theta2:
#                 edge2(p,q)

# for p in points:
#     point(p)

# c.writePDFfile("Beta-skeleton")


